"use strict";(self.webpackChunkthiagola_92_github_io=self.webpackChunkthiagola_92_github_io||[]).push([[66],{28551:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>t,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var s=i(85893),r=i(11151);const o={authors:"thiagola92",tags:["ipc","interprocess communication","inter-process communication"]},t="IPC",a={permalink:"/en/blog/2025/03/14/IPC",editUrl:"https://github.com/thiagola92/thiagola92.github.io/tree/master/blog/2025-03-14-IPC/index.md",source:"@site/blog/2025-03-14-IPC/index.md",title:"IPC",description:"(Interprocess Communication)",date:"2025-03-14T00:00:00.000Z",formattedDate:"March 14, 2025",tags:[{label:"ipc",permalink:"/en/blog/tags/ipc"},{label:"interprocess communication",permalink:"/en/blog/tags/interprocess-communication"},{label:"inter-process communication",permalink:"/en/blog/tags/inter-process-communication"}],hasTruncateMarker:!1,authors:[{name:"Thiago Lages de Alencar",title:"Desenvolvedor de Software",url:"https://github.com/thiagola92",imageURL:"/img/dino.svg",key:"thiagola92"}],frontMatter:{authors:"thiagola92",tags:["ipc","interprocess communication","inter-process communication"]},unlisted:!1,nextItem:{title:"Memory Allocation",permalink:"/en/blog/2025/03/13/memory-allocation"}},d={authorsImageUrls:[void 0]},l=[{value:"Low Level",id:"low-level",level:2},{value:"File",id:"file",level:3},{value:"File Locking",id:"file-locking",level:3},{value:"Signal",id:"signal",level:3},{value:"Pipe",id:"pipe",level:3},{value:"Named Pipe (FIFO)",id:"named-pipe-fifo",level:3},{value:"Message Queue",id:"message-queue",level:3},{value:"Shared Memory",id:"shared-memory",level:3},{value:"Socket",id:"socket",level:3},{value:"High Level",id:"high-level",level:2},{value:"Remote Procedure Call",id:"remote-procedure-call",level:3},{value:"HTTP API",id:"http-api",level:3},{value:"WebSocket",id:"websocket",level:3},{value:"References",id:"references",level:2}];function c(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"(Interprocess Communication)"})}),"\n",(0,s.jsx)(n.p,{children:"Existem diversas maneiras de fazer dois processos distintos se comunicarem e isto torna bem dif\xedcil de escolher qual deles utilizar sem antes conhecermos o m\xednimo delas."}),"\n",(0,s.jsx)(n.h2,{id:"low-level",children:"Low Level"}),"\n",(0,s.jsx)(n.h3,{id:"file",children:"File"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Escrever os dados em um arquivo e esperar que outro processo leia o arquivo."})}),"\n",(0,s.jsx)(n.p,{children:"Pode ser estranho por ser muito simples mas acontece que passar dados entre processos n\xe3o precisa ser complicado."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Inclusive, \xe9 como eu implementei ",(0,s.jsx)(n.a,{href:"https://github.com/thiagola92/Mondot",children:"Mondot"})," (GUI para MongoDB)."]})}),"\n",(0,s.jsx)(n.p,{children:"Exemplo:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Processo 1","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Constantemente verifica se o arquivo possui conte\xfado"}),"\n",(0,s.jsx)(n.li,{children:"Se notar que possui, exibe o conte\xfado na tela e esvazia o arquivo"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Processo 2","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Constantemente verifica se o arquivo est\xe1 vazio"}),"\n",(0,s.jsx)(n.li,{children:"Se notar que est\xe1 vazio, escreve conte\xfado no arquivo"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-C",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint BUFFER_SIZE = 256;\n\nint main(void) {\n  FILE *file = fopen("input.txt", "r+");\n  char *buffer = (char *)malloc(BUFFER_SIZE);\n  int count = 0;\n\n  memset(buffer, 0, BUFFER_SIZE);\n\n  printf("Waiting message\\n");\n\n  do {\n    fseek(file, 0, SEEK_SET);\n    count = fread(buffer, sizeof(char), BUFFER_SIZE, file);\n  } while (count == 0);\n\n  printf("Reading message\\n\\n");\n\n  do {\n    printf("%s", buffer);\n    count = fread(buffer, sizeof(char), BUFFER_SIZE, file);\n\n    if (count < BUFFER_SIZE) {\n      buffer[count] = \'\\0\';\n    }\n\n  } while (count != 0);\n\n  printf("\\n\\nClearing file\\n");\n  freopen("input.txt", "w", file);\n  fclose(file);\n\n  return 0;\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-C",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint BUFFER_SIZE = 256;\n\nint main(void) {\n  FILE *file = fopen("../process1/input.txt", "w+");\n  char *buffer = (char *)malloc(BUFFER_SIZE);\n  int count = 0;\n\n  memset(buffer, 0, BUFFER_SIZE);\n\n  printf("Waiting file to be empty\\n");\n\n  do {\n    fseek(file, 0, SEEK_SET);\n    count = fread(buffer, sizeof(char), BUFFER_SIZE, file);\n  } while (count != 0);\n\n  printf("Writing message\\n");\n  fprintf(file, "Hello world");\n  fclose(file);\n\n  return 0;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Note que neste exemplo eu leio e escrevo no arquivo constantemente, por\xe9m isto \xe9 apenas um exemplo!"}),"\n",(0,s.jsx)(n.p,{children:"A realidade \xe9 que n\xf3s devemos ler ou escrever no arquivo na frequ\xeancia que acharmos necess\xe1rio para nosso programa. S\xf3 quero que voc\xea entenda que este m\xe9todo IPC \xe9 sobre processos usarem arquivos para interagir uns com os outros."}),"\n",(0,s.jsx)(n.h3,{id:"file-locking",children:"File Locking"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["Escrever os dados em um arquivo e esperar que outro processo leia o arquivo ",(0,s.jsx)(n.strong,{children:"por\xe9m respeitando as travas"}),"."]})}),"\n",(0,s.jsx)(n.p,{children:"Um grande problema da maneira anterior \xe9 dois processos interagirem exatamente no mesmo momento com o arquivo. Imagine que um processo comece a ler enquanto um outro n\xe3o terminou de escrever, isso far\xe1 com que ele leia conte\xfado incompleto."}),"\n",(0,s.jsx)(n.p,{children:"A maneira de travar arquivos varia em cada sistema operacional. Por exemplo, no Linux temos:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"flock"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"lockf"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"fcntl"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Utilizaremos ",(0,s.jsx)(n.code,{children:"lockf"})," para aprimorar o exemplo utilizado para arquivos:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Processo 1","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Constantemente:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Espera obter a trava para o arquivo"}),"\n",(0,s.jsx)(n.li,{children:"Verifica se o arquivo possui conte\xfado"}),"\n",(0,s.jsxs)(n.li,{children:["Libera a trava do arquivo ",(0,s.jsx)(n.strong,{children:"se ele n\xe3o tiver"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Se notar que possui, exibe o conte\xfado na tela, esvazia o arquivo e ",(0,s.jsx)(n.strong,{children:"libera a trava"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Processo 2","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Constantemente:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Espera obter a trava para o arquivo"}),"\n",(0,s.jsx)(n.li,{children:"Verifica se o arquivo possui conte\xfado"}),"\n",(0,s.jsxs)(n.li,{children:["Libera a trava do arquivo ",(0,s.jsx)(n.strong,{children:"se ele tiver"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Se notar que est\xe1 vazio, escreve conte\xfado no arquivo e ",(0,s.jsx)(n.strong,{children:"libera a trava"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-C",children:'#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nint BUFFER_SIZE = 256;\n\nint main(void) {\n  int fd = open("input.txt", O_RDWR);\n  char *buffer = (char *)malloc(BUFFER_SIZE);\n  int count = 0;\n\n  memset(buffer, 0, BUFFER_SIZE);\n\n  printf("Waiting message\\n");\n\n  while (1) {\n    lockf(fd, F_LOCK, 0);\n    lseek(fd, 0, SEEK_SET);\n    count = read(fd, buffer, BUFFER_SIZE);\n\n    if (count != 0) {\n        break;\n    }\n\n    lockf(fd, F_ULOCK, 0);\n  }\n\n  printf("Reading message\\n\\n");\n\n  do {\n    printf("%s", buffer);\n    count = read(fd, buffer, BUFFER_SIZE);\n\n    if (count < BUFFER_SIZE) {\n      buffer[count] = \'\\0\';\n    }\n\n  } while (count != 0);\n\n  printf("\\n\\nClearing file\\n");\n  ftruncate(fd, 0);\n  lockf(fd, F_ULOCK, 0);\n  close(fd);\n\n  return 0;\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-C",children:'#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nint BUFFER_SIZE = 256;\n\nchar* MESSAGE = "Hello world";\n\nint main(void) {\n  int fd = open("input.txt", O_RDWR);\n  char *buffer = (char *)malloc(BUFFER_SIZE);\n  int count = 0;\n\n  memset(buffer, 0, BUFFER_SIZE);\n\n  printf("Waiting file to be empty\\n");\n\n  while (1) {\n    lockf(fd, F_LOCK, 0);\n    lseek(fd, 0, SEEK_SET);\n    count = read(fd, buffer, BUFFER_SIZE);\n\n    if (count == 0) {\n        break;\n    }\n\n    lockf(fd, F_ULOCK, 0);\n  }\n\n  printf("Writing message\\n");\n  ftruncate(fd, 0);\n  lseek(fd, 0, SEEK_SET);\n  write(fd, MESSAGE, strlen(MESSAGE));\n  lockf(fd, F_ULOCK, 0);\n  close(fd);\n\n  return 0;\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"signal",children:"Signal"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Enviar um signal ao processo/thread para uma fun\xe7\xe3o tratar"})}),"\n",(0,s.jsx)(n.p,{children:"Diferente de outros IPC, signal n\xe3o \xe9 focado em comunica\xe7\xe3o no n\xedvel de aplica\xe7\xe3o, ent\xe3o n\xe3o \xe9 muito utilizado para enviar dados, normalmente apenas para notificar outro processo da ocorr\xeancia de algo."}),"\n",(0,s.jsxs)(n.p,{children:["A melhor maneira de ter uma id\xe9ia da utilidade dos signals \xe9 vendo o ",(0,s.jsx)(n.code,{children:"signal.h"})," do sistema operacional. No caso do Linux:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-C",metastring:'title="bits/signum-generic.h"',children:"/* We define here all the signal names listed in POSIX (1003.1-2008);\n   as of 1003.1-2013, no additional signals have been added by POSIX.\n   We also define here signal names that historically exist in every\n   real-world POSIX variant (e.g. SIGWINCH).\n\n   Signals in the 1-15 range are defined with their historical numbers.\n   For other signals, we use the BSD numbers.\n   There are two unallocated signal numbers in the 1-31 range: 7 and 29.\n   Signal number 0 is reserved for use as kill(pid, 0), to test whether\n   a process exists without sending it a signal.  */\n\n/* ISO C99 signals.  */\n#define\tSIGINT\t\t2\t/* Interactive attention signal.  */\n#define\tSIGILL\t\t4\t/* Illegal instruction.  */\n#define\tSIGABRT\t\t6\t/* Abnormal termination.  */\n#define\tSIGFPE\t\t8\t/* Erroneous arithmetic operation.  */\n#define\tSIGSEGV\t\t11\t/* Invalid access to storage.  */\n#define\tSIGTERM\t\t15\t/* Termination request.  */\n\n/* Historical signals specified by POSIX. */\n#define\tSIGHUP\t\t1\t/* Hangup.  */\n#define\tSIGQUIT\t\t3\t/* Quit.  */\n#define\tSIGTRAP\t\t5\t/* Trace/breakpoint trap.  */\n#define\tSIGKILL\t\t9\t/* Killed.  */\n#define\tSIGPIPE\t\t13\t/* Broken pipe.  */\n#define\tSIGALRM\t\t14\t/* Alarm clock.  */\n\n/* Archaic names for compatibility.  */\n#define\tSIGIO\t\tSIGPOLL\t/* I/O now possible (4.2 BSD).  */\n#define\tSIGIOT\t\tSIGABRT\t/* IOT instruction, abort() on a PDP-11.  */\n#define\tSIGCLD\t\tSIGCHLD\t/* Old System V name */\n\n/* Not all systems support real-time signals.  bits/signum.h indicates\n   that they are supported by overriding __SIGRTMAX to a value greater\n   than __SIGRTMIN.  These constants give the kernel-level hard limits,\n   but some real-time signals may be used internally by glibc.  Do not\n   use these constants in application code; use SIGRTMIN and SIGRTMAX\n   (defined in signal.h) instead.  */\n\n/* Include system specific bits.  */\n#include <bits/signum-arch.h>\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-C",metastring:'title="bits/signum-arch.h"',children:"/* Adjustments and additions to the signal number constants for\n   most Linux systems.  */\n\n#define SIGSTKFLT\t16\t/* Stack fault (obsolete).  */\n#define SIGPWR\t\t30\t/* Power failure imminent.  */\n\n/* Historical signals specified by POSIX. */\n#define SIGBUS\t\t 7\t/* Bus error.  */\n#define SIGSYS\t\t31\t/* Bad system call.  */\n\n/* New(er) POSIX signals (1003.1-2008, 1003.1-2013).  */\n#define SIGURG\t\t23\t/* Urgent data is available at a socket.  */\n#define SIGSTOP\t\t19\t/* Stop, unblockable.  */\n#define SIGTSTP\t\t20\t/* Keyboard stop.  */\n#define SIGCONT\t\t18\t/* Continue.  */\n#define SIGCHLD\t\t17\t/* Child terminated or stopped.  */\n#define SIGTTIN\t\t21\t/* Background read from control terminal.  */\n#define SIGTTOU\t\t22\t/* Background write to control terminal.  */\n#define SIGPOLL\t\t29\t/* Pollable event occurred (System V).  */\n#define SIGXFSZ\t\t25\t/* File size limit exceeded.  */\n#define SIGXCPU\t\t24\t/* CPU time limit exceeded.  */\n#define SIGVTALRM\t26\t/* Virtual timer expired.  */\n#define SIGPROF\t\t27\t/* Profiling timer expired.  */\n#define SIGUSR1\t\t10\t/* User-defined signal 1.  */\n#define SIGUSR2\t\t12\t/* User-defined signal 2.  */\n\n/* Nonstandard signals found in all modern POSIX systems\n   (including both BSD and Linux).  */\n#define SIGWINCH\t28\t/* Window size change (4.3 BSD, Sun).  */\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Por padr\xe3o alguns signals j\xe1 possuem comportamentos pr\xe9-definidos. Por exemplo: ",(0,s.jsx)(n.code,{children:"SIGINT"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Quando executando um programa pelo terminal, se voc\xea apertar ",(0,s.jsx)(n.code,{children:"Ctrl+C"})," o signal enviado para o processo \xe9 o ",(0,s.jsx)(n.code,{children:"SIGINT"}),"."]})}),"\n",(0,s.jsx)(n.p,{children:"Fica a sua escolha se voc\xea deseja sobreescrever o comportamento de um signal (caso ele tenha um comportamento padr\xe3o)."}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsxs)(n.p,{children:["Existem dois signals que n\xe3o podem ter o comportamento sobreescrito: ",(0,s.jsx)(n.code,{children:"SIGKILL"})," e ",(0,s.jsx)(n.code,{children:"SIGSTOP"}),"."]})}),"\n",(0,s.jsx)(n.p,{children:"Quando um Signal \xe9 recebido pelo seu processo, o kernel pausa o fluxo normal do seu programa para executar a fun\xe7\xe3o que voc\xea definiu para aquele signal. Caso voc\xea n\xe3o tenha definido alguma fun\xe7\xe3o, o comportamento padr\xe3o \xe9 executado (o qual pode ser ignorar o signal)."}),"\n",(0,s.jsx)(n.p,{children:"Signals permitem que voc\xea envie um inteiro ou ponteiro junto deles."}),"\n",(0,s.jsx)(n.p,{children:"No caso de comunica\xe7\xe3o entre processos, apenas o inteiro costuma ser \xfatil pois n\xe3o podemos acessar o espa\xe7o de mem\xf3ria de outro processo."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"Por\xe9m se estivermos utilizando para comunica\xe7\xe3o entre threads, enviar o endere\xe7o de um dado espec\xedfico \xe9 bem \xfatil."})}),"\n",(0,s.jsxs)(n.p,{children:["Existem dois signals reservados para o uso da aplica\xe7\xe3o/usu\xe1rio: ",(0,s.jsx)(n.code,{children:"SIGUSR1"})," e ",(0,s.jsx)(n.code,{children:"SIGUSR2"}),". Podemos utiliza-los para a comunica\xe7\xe3o de nossos processo."]}),"\n",(0,s.jsx)(n.p,{children:"Por exemplo, enviar um n\xfamero entre processos:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Processo 1","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Exibe o PID no terminal"}),"\n",(0,s.jsx)(n.li,{children:"Espera em loop pelo signal com o n\xfamero"}),"\n",(0,s.jsx)(n.li,{children:"Encerrar ao receber o n\xfamero"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Processo 2","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"L\xea o PID passado por argumento"}),"\n",(0,s.jsxs)(n.li,{children:["Envia o n\xfamero para o processo desejado utilizadno o signal ",(0,s.jsx)(n.code,{children:"SIGUSR1"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-C",children:'#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nbool loop = true;\n\n// Normally the function would only receive a number as paramter.\n// But we setted flag SA_SIGINFO into our sigaction.\nvoid on_user_signal(int signal_number, siginfo_t *signal_info, void *x) {\n  printf("Received signal: %d\\n", signal_number);\n  printf("Together with number: %d\\n", signal_info->si_value.sival_int);\n\n  loop = false;\n}\n\nint main(void) {\n  struct sigaction signal_action;\n  signal_action.sa_flags = SA_SIGINFO;\n  signal_action.sa_sigaction = on_user_signal;\n\n  // sigaction() is recommended nowadays instead of signal().\n  sigaction(SIGUSR1, &signal_action, NULL);\n\n  printf("My PID: %d\\n", getpid());\n  printf("Waiting signal\\n");\n\n  while (loop) {\n  }\n\n  return 0;\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-C",children:'#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint NUMBER = 42;\n\nint main(int argc, char **args) {\n  if (argc != 2) {\n    printf("Needs to pass PID through arguments\\n");\n    return 1;\n  }\n\n  union sigval signal_value = {NUMBER};\n  int pid = atoi(args[1]);\n\n  printf("Sending signal to PID: %d\\n", pid);\n  printf("Together with number: %d\\n", NUMBER);\n  sigqueue(pid, SIGUSR1, signal_value);\n\n  return 0;\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"pipe",children:"Pipe"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Ler e escrever no pipe de outro processo filho/pai"})}),"\n",(0,s.jsxs)(n.admonition,{type:"warning",children:[(0,s.jsx)(n.p,{children:"Para entender bem pipe, recomendo entender bem file descriptor (o que eu n\xe3o entendia muito bem)."}),(0,s.jsxs)(n.p,{children:["Recomenda\xe7\xe3o: ",(0,s.jsx)(n.a,{href:"https://www.youtube.com/watch?v=rW_NV6rf0rM",children:"https://www.youtube.com/watch?v=rW_NV6rf0rM"})]})]}),"\n",(0,s.jsx)(n.p,{children:"O conceito de pipes \xe9 bem simples, voc\xea escreve em um lado do pipe e para algu\xe9m ler do outro lado dele."}),"\n",(0,s.jsxs)(n.p,{children:["Podemos criar um pipe com o comando ",(0,s.jsx)(n.code,{children:"pipe()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-C",children:'#include <stdio.h>\n#include <unistd.h>\n\nint main(void) {\n  int file_descriptors[2];\n\n  pipe(file_descriptors);\n\n  printf("Pipe input: %d\\n", file_descriptors[0]);\n  printf("Pipe output: %d\\n", file_descriptors[1]);\n\n  return 0;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["O comando ",(0,s.jsx)(n.code,{children:"pipe()"})," inseri dois file descriptors, um para a entrada do pipe e outro para a sa\xedda do pipe, no nosso array. O comando tamb\xe9m retorna -1 em caso de erro, mas eu irei ignorar tratamentos de erros nesses exemplos."]}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsx)(n.p,{children:"O que \xe9 um file descriptor? \xc9 um n\xfamero inteiro utilizado pelo seu processo para pedir ao sistema operacional por acesso a um arquivo. \xc9 preciso entender que quando voc\xea escreve/l\xea de um arquivo, voc\xea na verdade est\xe1 pedindo para o sistema operacional fazer isto para voc\xea."}),(0,s.jsx)(n.p,{children:"O sistema operacional possue uma tabela com todos os files descriptors de cada processo (e outras informa\xe7\xf5es relacionadas ao arquivo)."}),(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"processo id"}),(0,s.jsx)(n.th,{children:"file descriptor"}),(0,s.jsx)(n.th,{children:"file position"}),(0,s.jsx)(n.th,{children:"..."})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1034"}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"..."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"567"}),(0,s.jsx)(n.td,{children:"7"}),(0,s.jsx)(n.td,{children:"10"}),(0,s.jsx)(n.td,{children:"..."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"3945"}),(0,s.jsx)(n.td,{children:"4"}),(0,s.jsx)(n.td,{children:"4959"}),(0,s.jsx)(n.td,{children:"..."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"12034"}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"283"}),(0,s.jsx)(n.td,{children:"..."})]})]})]}),(0,s.jsx)(n.p,{children:'Ent\xe3o toda vez que voc\xea deseja abrir um arquivo, o sistema operacional te entrega um file descriptor. Este file descriptor \xe9 como se fosse um ticket que permite voc\xea pedir ao sistema operacional por intera\xe7\xf5es com aquele arquivo ("Oi sistema operacional, eu gostaria de escrever no arquivo relacionado a este ticket").'})]}),"\n",(0,s.jsxs)(n.p,{children:["Come\xe7amos com o m\xednimo de IPC quando utilizando ",(0,s.jsx)(n.code,{children:"pipe()"})," com ",(0,s.jsx)(n.code,{children:"fork()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-C",children:'#include <stdio.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\nint main(void) {\n  char message[3];\n  int file_descriptors[2];\n\n  pipe(file_descriptors);\n\n  if (fork()) {\n    // Parent\n    wait(NULL);\n    read(file_descriptors[0], message, 3);\n    printf("Message: %s\\n", message);\n  } else {\n    // Child\n    write(file_descriptors[1], "hi", 3);\n  }\n\n  return 0;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Cada processo possui seus pr\xf3prios file descriptors, que por sua vez levam a um arquivo/pipe/etc. Por\xe9m quando fazemos um ",(0,s.jsx)(n.code,{children:"fork()"}),", nossas entradas na tabela de file descriptors tamb\xe9m \xe9 clonada."]}),"\n",(0,s.jsx)(n.p,{children:"Por exemplo, vamos supor que o ID do processo pai \xe9 1034 e o filho nasceu com o ID 1035. Quando o filho nasce, ele herda todos os files descriptors:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"processo id"}),(0,s.jsx)(n.th,{children:"file descriptor"}),(0,s.jsx)(n.th,{children:"file position"}),(0,s.jsx)(n.th,{children:"..."}),(0,s.jsx)(n.th,{children:"leva ao pipe"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1034"}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"..."}),(0,s.jsx)(n.td,{children:"1000"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1035"}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"..."}),(0,s.jsx)(n.td,{children:"1000"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Ou seja, o file descriptor com n\xfamero 3 do pai e do filho ir\xe3o levar ao mesmo arquivo/pipe/etc."}),"\n",(0,s.jsx)(n.p,{children:"Isto n\xe3o quer dizer que todos os file descriptors futuros seram compartilhados! Por exemplo:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-C",children:"#include <sys/wait.h>\n#include <unistd.h>\n\nint main(void) {\n  int file_descriptors[2];\n  int more_file_descriptors[2];\n\n  pipe(file_descriptors);\n\n  if (fork()) {\n    // Parent\n    pipe(more_file_descriptors);\n    wait(NULL);\n  } else {\n    // Child\n    pipe(more_file_descriptors);\n  }\n\n  return 0;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Ao chamar ",(0,s.jsx)(n.code,{children:"pipe()"})," dentro do pai ou do filho, voc\xea est\xe1 pedindo para o sistema operacional criar um pipe para aquele processo. O pai e filho receberam pipes distintos embora possuam o mesmo file descriptor (justamente pois file descriptors s\xe3o identificadores \xfanicos do processo)."]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"processo id"}),(0,s.jsx)(n.th,{children:"file descriptor"}),(0,s.jsx)(n.th,{children:"file position"}),(0,s.jsx)(n.th,{children:"..."}),(0,s.jsx)(n.th,{children:"leva ao pipe"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1034"}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"..."}),(0,s.jsx)(n.td,{children:"1000"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1034"}),(0,s.jsx)(n.td,{children:"4"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"..."}),(0,s.jsx)(n.td,{children:"2000"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1034"}),(0,s.jsx)(n.td,{children:"5"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"..."}),(0,s.jsx)(n.td,{children:"2000"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1035"}),(0,s.jsx)(n.td,{children:"3"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"..."}),(0,s.jsx)(n.td,{children:"1000"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1035"}),(0,s.jsx)(n.td,{children:"4"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"..."}),(0,s.jsx)(n.td,{children:"3000"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1035"}),(0,s.jsx)(n.td,{children:"5"}),(0,s.jsx)(n.td,{children:"0"}),(0,s.jsx)(n.td,{children:"..."}),(0,s.jsx)(n.td,{children:"3000"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"named-pipe-fifo",children:"Named Pipe (FIFO)"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Ler e escrever no pipe de outro processo"})}),"\n",(0,s.jsx)(n.p,{children:"A diferen\xe7a deste pipe para o anterior \xe9 que qualquer processo pode se ligar a ele, seja para escrever ou ler, pois ele \xe9 praticamente um arquivo no sistema."}),"\n",(0,s.jsxs)(n.p,{children:["O comando utilizado para criar o este pipe \xe9 ",(0,s.jsx)(n.code,{children:"mkfifo()"})," e da mesma maneira que arquivos tem permiss\xf5es... Voc\xea deve passar as permiss\xf5es do arquivo como par\xe2metro, no nosso caso irei passar ",(0,s.jsx)(n.code,{children:"0666"})," (rw-rw-rw)."]}),"\n",(0,s.jsx)(n.p,{children:"Lembrando que um pipe s\xf3 \xe9 um pipe se tiver pelo menos um lado de entrada e outro de sa\xedda, ou seja, fun\xe7\xf5es de escrita/leitura do pipe ir\xe3o ficar travadas at\xe9 que o outro lado do pipe exista."}),"\n",(0,s.jsxs)(n.p,{children:["Enquanto n\xe3o tiver ningu\xe9m lendo do pipe, o comando ",(0,s.jsx)(n.code,{children:"write()"})," ir\xe1 ficar em loop esperando algu\xe9m para ler.",(0,s.jsx)(n.br,{}),"\n","Enquanto n\xe3o tiver ningu\xe9m escrevendo no pipe, o comando ",(0,s.jsx)(n.code,{children:"read()"})," ir\xe1 ficar em loop esperando algu\xe9m come\xe7ar a escrever."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Processo 1","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Tenta criar o named pipe com devidas permiss\xf5es"}),"\n",(0,s.jsx)(n.li,{children:"Abre o named pipe para escrita"}),"\n",(0,s.jsx)(n.li,{children:"Escreve no arquivo a mensagem"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Processo 2","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Tenta criar o named pipe com devidas permiss\xf5es"}),"\n",(0,s.jsx)(n.li,{children:"Abre o named pipe para leitura"}),"\n",(0,s.jsx)(n.li,{children:"Le do arquivo a mensagem"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-C",children:'#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint main(void) {\n  mkfifo("pipefile", 0666);\n\n  int file_descriptor = open("pipefile", O_WRONLY);\n  write(file_descriptor, "hi", 3);\n  printf("Message sent\\n");\n  \n  return 0;\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-C",children:'#include <stdio.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint main(void) {\n  char message[3];\n\n  mkfifo("pipefile", 0666);\n\n  int file_descriptor = open("pipefile", O_RDONLY);\n  read(file_descriptor, &message, 3);\n  printf("Message: %s\\n", message);\n  \n  return 0;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"\xc9 poss\xedvel ter mais que um processo lendo do mesmo pipe mas \xe9 incerto de quem receber\xe1 o conte\xfado ou se dois processos ir\xe3o receber o mesmo conte\xfado."}),"\n",(0,s.jsxs)(n.p,{children:["Tamb\xe9m \xe9 poss\xedvel n\xe3o ficar em loop esperando algu\xe9m come\xe7ar a ler/escrever do outro lado do pipe, basta fazer um ",(0,s.jsx)(n.em,{children:"or"})," quando abrindo o pipe (",(0,s.jsx)(n.code,{children:"O_WRONLY | O_NDELAY"})," ou ",(0,s.jsx)(n.code,{children:"O_RDONLY | O_NDELAY"}),")."]}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsxs)(n.p,{children:["Originalmente chamado de FIFO pelo comportamento cl\xe1ssico ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)",children:'"first in, first out"'}),", por\xe9m atualmente \xe9 mais conhecido pelo nome ",(0,s.jsx)(n.em,{children:"named pipe"})," que deixa implicito que se comporta basicamente igual a um pipe."]}),(0,s.jsxs)(n.p,{children:["Originalmente criado utilizando a fun\xe7\xe3o ",(0,s.jsx)(n.code,{children:"mknod()"})," e passando como argumento ",(0,s.jsx)(n.code,{children:"S_IFIFO"})," para especificar o tipo de arquivo. Justamente por est\xe1 fun\xe7\xe3o suportar diversos tipos:"]}),(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"#define"}),(0,s.jsx)(n.th,{children:"value"}),(0,s.jsx)(n.th,{children:"file type"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"S_IFSOCK"}),(0,s.jsx)(n.td,{children:"0140000"}),(0,s.jsx)(n.td,{children:"socket"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"S_IFLNK"}),(0,s.jsx)(n.td,{children:"0120000"}),(0,s.jsx)(n.td,{children:"symbolic link"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"S_IFREG"}),(0,s.jsx)(n.td,{children:"0100000"}),(0,s.jsx)(n.td,{children:"regular file"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"S_IFBLK"}),(0,s.jsx)(n.td,{children:"0060000"}),(0,s.jsx)(n.td,{children:"block device"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"S_IFDIR"}),(0,s.jsx)(n.td,{children:"0040000"}),(0,s.jsx)(n.td,{children:"directory"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"S_IFCHR"}),(0,s.jsx)(n.td,{children:"0020000"}),(0,s.jsx)(n.td,{children:"character device"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"S_IFIFO"}),(0,s.jsx)(n.td,{children:"0010000"}),(0,s.jsx)(n.td,{children:"FIFO"})]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"message-queue",children:"Message Queue"}),"\n",(0,s.jsx)(n.h3,{id:"shared-memory",children:"Shared Memory"}),"\n",(0,s.jsx)(n.h3,{id:"socket",children:"Socket"}),"\n",(0,s.jsx)(n.h2,{id:"high-level",children:"High Level"}),"\n",(0,s.jsx)(n.h3,{id:"remote-procedure-call",children:"Remote Procedure Call"}),"\n",(0,s.jsx)(n.h3,{id:"http-api",children:"HTTP API"}),"\n",(0,s.jsx)(n.h3,{id:"websocket",children:"WebSocket"}),"\n",(0,s.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://beej.us/guide/bgipc/",children:"https://beej.us/guide/bgipc/"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Inter-process_communication",children:"https://en.wikipedia.org/wiki/Inter-process_communication"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.youtube.com/watch?v=Y2mDwW2pMv4",children:"https://www.youtube.com/watch?v=Y2mDwW2pMv4"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.youtube.com/watch?v=83M5-NPDeWs",children:"https://www.youtube.com/watch?v=83M5-NPDeWs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://man7.org/linux/man-pages/man2/sigaction.2.html",children:"https://man7.org/linux/man-pages/man2/sigaction.2.html"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://man7.org/linux/man-pages/man3/sigqueue.3.html",children:"https://man7.org/linux/man-pages/man3/sigqueue.3.html"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Signal_(IPC)",children:"https://en.wikipedia.org/wiki/Signal_(IPC)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Pipeline_(Unix)",children:"https://en.wikipedia.org/wiki/Pipeline_(Unix)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/File_descriptor",children:"https://en.wikipedia.org/wiki/File_descriptor"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://man7.org/linux/man-pages/man3/mkfifo.3.html",children:"https://man7.org/linux/man-pages/man3/mkfifo.3.html"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://man7.org/linux/man-pages/man2/mknod.2.html",children:"https://man7.org/linux/man-pages/man2/mknod.2.html"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://man7.org/linux/man-pages/man7/inode.7.html",children:"https://man7.org/linux/man-pages/man7/inode.7.html"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>a,a:()=>t});var s=i(67294);const r={},o=s.createContext(r);function t(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);