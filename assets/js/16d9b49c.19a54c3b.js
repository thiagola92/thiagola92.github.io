"use strict";(self.webpackChunkthiagola_92_github_io=self.webpackChunkthiagola_92_github_io||[]).push([[2205],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>g});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=a.createContext({}),u=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},m=function(e){var n=u(e.components);return a.createElement(p.Provider,{value:n},e.children)},c="mdxType",s={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=u(t),d=r,g=c["".concat(p,".").concat(d)]||c[d]||s[d]||o;return t?a.createElement(g,i(i({ref:n},m),{},{components:t})):a.createElement(g,i({ref:n},m))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=d;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[c]="string"==typeof e?e:r,i[1]=l;for(var u=2;u<o;u++)i[u]=t[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},7946:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>s,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var a=t(7462),r=(t(7294),t(3905));const o={authors:"thiagola92-calm",tags:["enum","rust","union"]},i="Unions e Enums",l={permalink:"/blog/2023/12/31/union-enum",editUrl:"https://github.com/thiagola92/thiagola92.github.io/tree/master/blog/2023-12-31-union-enum/index.md",source:"@site/blog/2023-12-31-union-enum/index.md",title:"Unions e Enums",description:"Ao come\xe7ar a estudar Rust percebi o qu\xe3o a rela\xe7\xe3o deste dois s\xe3o pr\xf3xima, por\xe9m primeiro precisamos rever unions e enums.",date:"2023-12-31T00:00:00.000Z",formattedDate:"December 31, 2023",tags:[{label:"enum",permalink:"/blog/tags/enum"},{label:"rust",permalink:"/blog/tags/rust"},{label:"union",permalink:"/blog/tags/union"}],hasTruncateMarker:!1,authors:[{name:"Thiago Lages de Alencar",title:"Desenvolvedor de Software",url:"https://github.com/thiagola92",imageURL:"https://cdn.discordapp.com/attachments/807746464833863709/1110163174289850378/tiktok.png",key:"thiagola92-calm"}],frontMatter:{authors:"thiagola92-calm",tags:["enum","rust","union"]},nextItem:{title:"Forward Kinematics",permalink:"/blog/2023/12/18/fk"}},p={authorsImageUrls:[void 0]},u=[{value:"C",id:"c",level:3},{value:"Rust",id:"rust",level:3}],m={toc:u},c="wrapper";function s(e){let{components:n,...t}=e;return(0,r.kt)(c,(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Ao come\xe7ar a estudar Rust percebi o qu\xe3o a rela\xe7\xe3o deste dois s\xe3o pr\xf3xima, por\xe9m primeiro precisamos rever unions e enums.  "),(0,r.kt)("h1",{id:"union"},"Union"),(0,r.kt)("p",null,"Se trata de utilizar o mesmo espa\xe7o de mem\xf3ria para armazenar um entre diversos tipos.  "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-C"},"union Content {\n    int i;\n    float f;\n    char c;\n};\n\nunion Content content;\n")),(0,r.kt)("p",null,"Nesse exemplo eu declarei um union que pode conter um dos seguintes valores: int, float, char.  "),(0,r.kt)("p",null,"Ent\xe3o eu posso escrever qualquer um dos tipos nele:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-C"},"content.i = 10;\ncontent.f = 5.0;\ncontent.c = 'a';\n")),(0,r.kt)("p",null,"O valor final de ",(0,r.kt)("inlineCode",{parentName:"p"},"content")," vai ser ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," pois foi o \xfaltimo valor que botamos.  "),(0,r.kt)("p",null,"Por\xe9m a parte importante \xe9 justamente o fato de usarmos o mesmo espa\xe7o de mem\xf3ria para armazenar qualquer um destes tipos."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-C"},'content.c = \'a\';\n\nprintf("%c\\n", content.c); // print "a"\nprintf("%c\\n", content.i); // print "a"\n')),(0,r.kt)("p",null,"Quando voc\xea declara uma union, o tamanho dela \xe9 definido pelo maior tamanho entre os tipos que ela precisa conseguir armazenar.  "),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Tipo"),(0,r.kt)("th",{parentName:"tr",align:null},"Tamanho"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"int"),(0,r.kt)("td",{parentName:"tr",align:null},"4 bytes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"float"),(0,r.kt)("td",{parentName:"tr",align:null},"4 bytes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"char"),(0,r.kt)("td",{parentName:"tr",align:null},"1 byte")))),(0,r.kt)("p",null,"No nosso caso o melhor tamanho seria 4 bytes, pois com ele voc\xea consegue armazenar o ",(0,r.kt)("inlineCode",{parentName:"p"},"char")," tamb\xe9m.  "),(0,r.kt)("p",null,"Nada impede de armazenarmos um ",(0,r.kt)("inlineCode",{parentName:"p"},"char")," e tentarmos ler aquele espa\xe7o da mem\xf3ria como um ",(0,r.kt)("inlineCode",{parentName:"p"},"int"),".  "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-C"},'content.c = \'a\';\n\nprintf("%c\\n", content.c); // print "a"\nprintf("%c\\n", content.i); // print "a"\n\n// O character \'a\' \xe9 nada mais que o n\xfamero 97 na mem\xf3ria.\nprintf("%i\\n", content.c); // print "97"\nprintf("%i\\n", content.i); // print "97"\n')),(0,r.kt)("p",null,"Resta a n\xf3s utilizar corretamente o valor daquele espa\xe7o de mem\xf3ria. "),(0,r.kt)("p",null,"Afinal n\xe3o queremos armazenar um ",(0,r.kt)("inlineCode",{parentName:"p"},"char")," na union e mais tarde no c\xf3digo tentar utilizar como um ",(0,r.kt)("inlineCode",{parentName:"p"},"int"),", n\xe9?  "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-C"},'content.c = \'a\';\n\n// ...\n\nprintf("%i\\n", content.i + 5); // print "102"\n')),(0,r.kt)("p",null,"N\xe3o s\xf3 isso como quando voc\xea armazena um valor naquele espa\xe7o de mem\xf3ria, ele apenas escreve no espa\xe7o que ele usaria.  "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-C"},'content.c = \'a\';\n\nprintf("%i\\n", content.c); // print "97"\nprintf("%i\\n", content.i); // print "97"\n\ncontent.i = -10;\ncontent.c = \'a\';\n\nprintf("%i\\n", content.c); // print "97"\nprintf("%i\\n", content.i); // print "-159"\n')),(0,r.kt)("p",null,"O que aconteceu aqui?  "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"In\xedcio do programa os ",(0,r.kt)("strong",{parentName:"li"},"4")," bytes de ",(0,r.kt)("inlineCode",{parentName:"li"},"content")," est\xe3o com zero"),(0,r.kt)("li",{parentName:"ul"},"Content recebeu no ",(0,r.kt)("strong",{parentName:"li"},"primeiro")," byte o valor 97 (pois ",(0,r.kt)("inlineCode",{parentName:"li"},"a")," == 97)"),(0,r.kt)("li",{parentName:"ul"},"Printamos utilizando ",(0,r.kt)("inlineCode",{parentName:"li"},"content.c"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Isto nos faz utilizar ",(0,r.kt)("strong",{parentName:"li"},"um")," byte"))),(0,r.kt)("li",{parentName:"ul"},"Printamos utilizando ",(0,r.kt)("inlineCode",{parentName:"li"},"content.i"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Isto nos faz utilizar ",(0,r.kt)("strong",{parentName:"li"},"4")," bytes"))),(0,r.kt)("li",{parentName:"ul"},"Content recebeu encheu os ",(0,r.kt)("strong",{parentName:"li"},"4")," bytes para formar o valor de -10"),(0,r.kt)("li",{parentName:"ul"},"Content recebeu no ",(0,r.kt)("strong",{parentName:"li"},"primeiro")," byte o valor 97"),(0,r.kt)("li",{parentName:"ul"},"Printamos utilizando ",(0,r.kt)("inlineCode",{parentName:"li"},"content.c"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Isto nos faz utilizar ",(0,r.kt)("strong",{parentName:"li"},"um")," byte (primeiro byte est\xe1 com o valor de 97)"))),(0,r.kt)("li",{parentName:"ul"},"Printamos utilizando ",(0,r.kt)("inlineCode",{parentName:"li"},"content.i"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Isto nos faz utilizar ",(0,r.kt)("strong",{parentName:"li"},"4")," bytes (primeiro byte + os outros 3 bytes que n\xe3o foram limpos)")))),(0,r.kt)("p",null,"Podemos confirmar isto settando para zero antes de preenchermos.  "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-C"},'content.c = \'a\';\n\nprintf("%i\\n", content.c); // print "97"\nprintf("%i\\n", content.i); // print "97"\n\ncontent.i = -10;\ncontent.i = 0;\ncontent.c = \'a\';\n\nprintf("%i\\n", content.c); // print "97"\nprintf("%i\\n", content.i); // print "97"\n')),(0,r.kt)("p",null,"Como podemos ver, \xe9 essencial termos uma maneira de identificar qual \xe9 o tipo atual na union.  "),(0,r.kt)("h1",{id:"enum"},"Enum"),(0,r.kt)("p",null,"Se trata de ligar um identificador a um n\xfamero \xfanico dentro de um agrupamento.  "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-C"},"enum Type {\n    Integer,\n    Floating,\n    Character,\n};\n\nenum Type type;\n")),(0,r.kt)("p",null,"Neste caso est\xe1 ligando:  "),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Identificador"),(0,r.kt)("th",{parentName:"tr",align:null},"N\xfamero"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Integer"),(0,r.kt)("td",{parentName:"tr",align:null},"0")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Floating"),(0,r.kt)("td",{parentName:"tr",align:null},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Character"),(0,r.kt)("td",{parentName:"tr",align:null},"2")))),(0,r.kt)("p",null,"Isto poupa trabalho de criarmos manualmente uma vari\xe1vel para cada valor, por exemplo:  "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-C"},"int Integer = 0;\nint Floating = 1;\nint Character = 2;\n")),(0,r.kt)("p",null,"Al\xe9m de deixarmos claro o tipo de vari\xe1vel durante a cria\xe7\xe3o dela (como um valor dentro daquele agrupamento).  "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-C"},'enum Type type = Integer;\n\nprintf("%i\\n", type); // print "0"\n')),(0,r.kt)("p",null,"Enfim, a essa altura voc\xea pode j\xe1 ter notado a import\xe2ncia de enum para unions.  "),(0,r.kt)("p",null,"Com eles podemos criar ligar um identificador a um tipo, como se fosse uma tag para aquele union.  "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-C"},"union content {\n    int i;\n    float f;\n    char c;\n} content;\n\nenum Types {\n    Integer,\n    Floating,\n    Character,\n} type;\n\ncontent.f = 5.0;\ntype = Floating;\n")),(0,r.kt)("p",null,"Note que precisamos atualizar ",(0,r.kt)("inlineCode",{parentName:"p"},"type")," sempre que mudarmos o tipo de ",(0,r.kt)("inlineCode",{parentName:"p"},"content"),", por\xe9m ganhamos a capacidade de tratar corretamente a union.  "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-C"},'if (type == Floating) {\n    printf("%f\\n", content.f);\n} else if (type == Character) {\n    printf("%c\\n", content.c);\n} else {\n    printf("%i\\n", content.i);\n}\n')),(0,r.kt)("p",null,"Este tipo de estrutura \xe9 t\xe3o comum que tem o nome de ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Tagged_union"},"Tagged Union"),".  "),(0,r.kt)("h1",{id:"rust-enum"},"Rust Enum"),(0,r.kt)("p",null,"Acredito que o ",(0,r.kt)("inlineCode",{parentName:"p"},"enum")," do Rust seja nada mais que um tagged union.  "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-Rust"},'#[derive(Debug)]\nenum Type {\n    Integer,\n    Floating,\n    Character,\n}\n\nprintln!("{:#?}", Type::Integer);\n')),(0,r.kt)("p",null,"Em outras lugares enum ligaria apenas identificadores a n\xfameros, por\xe9m em Rust voc\xea pode armazenar estrutura/tipos juntos aos enums.  "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-Rust"},'#[derive(Debug)]\nenum Type {\n    Integer(i32),\n    Floating(f32),\n    Character(char),\n}\n\nlet content: Type = Type::Floating(5.0);\n\nprintln!("{:#?}", content);\n')),(0,r.kt)("p",null,"Isso nos da uma estrutura s\xf3 que possue a capacidade de fazer o mesmo que tagged union e com menos chance do desenvolvedor cometer um erro.  "),(0,r.kt)("p",null,"Por exemplo, n\xe3o precisamos mais atualizar o tipo armazenado na vari\xe1vel toda vez que alteramos:  "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// C\ncontent.f = 5.0;\ntype = Floating;\n\n// Rust\nlet content: Type = Type::Floating(5.0);\n")),(0,r.kt)("p",null,"Rust \xe9 linguagem que preza bastante seguran\xe7a, ent\xe3o faria sentido tratar como se fosse uma \xfanica estrutura para evitar os problemas de union (embora Rust tenha o tipo union).  "),(0,r.kt)("h1",{id:"comparison"},"Comparison"),(0,r.kt)("h3",{id:"c"},"C"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-C"},"union content {\n    int i;\n    float f;\n    char c;\n} content;\n\nenum Types {\n    Integer,\n    Floating,\n    Character,\n} type;\n\ncontent.f = 5.0;\ntype = Floating;\n\nif (type == Floating) {\n    // Fazer algo com float\n} else if (type == Character) {\n    // Fazer algo com char\n} else {\n    // Fazer algo com int\n}\n")),(0,r.kt)("h3",{id:"rust"},"Rust"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-Rust"},"#[derive(Debug)]\nenum Type {\n    Integer(i32),\n    Floating(f32),\n    Character(char),\n}\n\nlet content: Type = Type::Floating(5.0);\n\nmatch content {\n    Type::Floating(f) => // Fazer algo com float\n    Type::Character(c) => // Fazer algo com char\n    Type::Integer(i) => // Fazer algo com int\n}\n")))}s.isMDXComponent=!0}}]);